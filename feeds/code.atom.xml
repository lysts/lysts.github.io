<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>lysts - code</title><link href="https://lysts.xyz/" rel="alternate"></link><link href="https://lysts.xyz/feeds/code.atom.xml" rel="self"></link><id>https://lysts.xyz/</id><updated>2023-07-14T17:24:00+01:00</updated><entry><title>Introduction to Algorithms</title><link href="https://lysts.xyz/introduction-to-algorithms.html" rel="alternate"></link><published>2023-07-14T17:24:00+01:00</published><updated>2023-07-14T17:24:00+01:00</updated><author><name>lysts</name></author><id>tag:lysts.xyz,2023-07-14:/introduction-to-algorithms.html</id><summary type="html">&lt;p class="first last"&gt;notes on recorded introductory compsci lectures available at MIT OpenCourseWare&lt;/p&gt;
</summary><content type="html">&lt;div class="contents topic" id="table-of-contents"&gt;
&lt;p class="topic-title"&gt;Table of Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#l1-algorithms-computation" id="toc-entry-1"&gt;L1: Algorithms &amp;amp; Computation&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#communicating-computational-problem-solving-its-efficiency-and-correctness" id="toc-entry-2"&gt;communicating computational problem solving, its efficiency and correctness&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="l1-algorithms-computation"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;L1: Algorithms &amp;amp; Computation&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="communicating-computational-problem-solving-its-efficiency-and-correctness"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;communicating computational problem solving, its efficiency and correctness&lt;/a&gt;&lt;/h3&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;computational problem?
can have multiple correct outputs to an input — define a problem by specifying a predicate, observe output. graph (binary)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;provide a deterministic algorithm to determine an answer...
algorithms that are general: can accept an arbitrarily sized input ex students for a class.
&amp;gt; general problems w arbitrarily sized inputs), algorithm
can't map what problem does, correct algorithm if output is correctly given
f:I—›O (functional programming definition)&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;birthday problem!:
- maintain record
- check if birthday in record: - if so return pair, - add new student to record,
- return none&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;use induction, recursion to prove correctness of algorithm...
inductive hypothesis: &amp;quot;if first k students contain match, algorithm returns
match before interviewing student k+1&amp;quot; = predicate
k increases up to n
base case: k=0 (case holds!)
assume IH true for k=k'{- if k' contains match —› alreated returned by
induction, - else if k'+1 contains match, alg k'+1 against all students}&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;prove efficiency...
dont measure time, instead count fundamental operations (ops), expect performance to depend on (with respect to) size of our input (n) = how well algorithm performs, not how well it's implemented
O(.) upper bound, omega (.) lower bounds (theta) corresponds to both
asymptotic analysis***&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;common algorithms that relate algorithm running time to input size: linear time algorithm
efficiency from top to bottom:
(theta)1 = constant time
()lg n= logarithmic time
()n = linear
()n lg n= log n
()n^2 = quadratic
()n^c = polynomial (c for constant)
2^(theta)n = exponential time, bad bc if plotted as function of n
&amp;gt; dnt want shit to go high. exponential crap.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;define model of computation...
word-RAM (RAM = random access memory, in constant time)
memory (string of bits), CPU where byte (chunk of bits = word) ex 64 bit
machine, to operate on to spit back, addressable memory 20 exabytes!! (data grabbed, registered separately, output also then registered then spat out)
ex can do integer arithmetic, logical ops (boolean etc), bitewise ops, on CPU memory&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;if you want to operate on non-constant n, linear amount of data, how long will it take?
concerns data structures, store large amount of data and operate on that&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="code"></category><category term="algorithms"></category><category term="compsci"></category></entry><entry><title>my current set-up</title><link href="https://lysts.xyz/my-current-set-up.html" rel="alternate"></link><published>2023-07-11T18:02:00+01:00</published><updated>2023-07-11T18:02:00+01:00</updated><author><name>lysts</name></author><id>tag:lysts.xyz,2023-07-11:/my-current-set-up.html</id><content type="html">&lt;p&gt;iterm2, vim, tmux, ranger, - how i use these tools and how i've configured them
for simplicity and easy use&lt;/p&gt;
</content><category term="code"></category></entry></feed>